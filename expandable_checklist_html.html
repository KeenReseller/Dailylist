<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Outline Checklist ‚Äî Import from .txt</title>
  <style>
  :root{
    --bg:#ffffff;
    --card:#ffffff;
    --muted:#4a5568;   /* slate-600 */
    --text:#111827;    /* gray-900 */
    --accent:#2563eb;  /* blue-600 */
    --outline:#e5e7eb; /* gray-200 */
    --outline-strong:#cbd5e1; /* slate-300 */
    --good:#16a34a;    /* green-600 */
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
    color:var(--text); background:var(--bg);
  }
  .wrap{max-width:1100px; margin:24px auto; padding:0 20px}
  header{display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom:16px}
  .title{font-size:22px; font-weight:700; letter-spacing:.3px}

  .controls{display:flex; gap:10px; flex-wrap:wrap; margin-left:auto}
  .btn{appearance:none; border:1px solid var(--outline-strong); background:linear-gradient(180deg, #ffffff, #f8fafc);
       color:var(--text); padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:600; box-shadow:0 4px 12px #00000014}
  .btn:hover{border-color:var(--accent); filter:brightness(1.02)}
  .btn.secondary{background:#f8fafc}
  .btn.good{border-color:var(--good); background:#f0fdf4}
  input[type="file"]{display:none}
  label.file{border:1px dashed var(--outline-strong); padding:10px 14px; border-radius:12px; cursor:pointer; color:var(--muted); background:#fafafa}

  .grid{display:grid; grid-template-columns: 1fr 1.4fr; gap:16px}
  @media (max-width: 980px){ .grid{ grid-template-columns: 1fr; } }

  .card{background:var(--card); border:1px solid var(--outline); border-radius:18px; box-shadow:0 10px 24px #00000010}
  .card h3{margin:0; padding:14px 16px; border-bottom:1px solid var(--outline); font-size:15px; color:var(--muted); letter-spacing:.2px}
  .card .content{padding:14px 16px}

  textarea#paste{width:100%; min-height:200px; background:#ffffff; color:var(--text); border:1px solid var(--outline);
    border-radius:12px; padding:12px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace}

  ul.tree{list-style:none; padding-left:0; margin:0}
  li.node{position:relative; padding-left:34px; margin:6px 0}

  .toggle{position:absolute; left:6px; top:7px; width:18px; height:18px; display:inline-grid; place-items:center; cursor:pointer;
    border-radius:6px; border:1px solid var(--outline-strong); background:#ffffff; font-size:12px; color:#64748b; user-select:none}
  .toggle.leaf{visibility:hidden}

  .label-row{display:flex; align-items:center; gap:10px}
  .label-row input[type="checkbox"]{width:18px; height:18px}
  .text{padding:6px 10px; border-radius:10px; transition:background .2s}
  .node.done > .label-row .text{background:#f0fdf4; text-decoration:line-through; color:#065f46}

  .children{margin-left:18px; border-left:1px dashed var(--outline-strong); padding-left:16px}

  .attachments{display:flex; flex-wrap:wrap; gap:6px; margin:6px 0 0 28px}
  .chip{font-size:12px; color:#1f2937; background:#f3f4f6; border:1px solid var(--outline); border-radius:999px; padding:3px 8px}

  .badges{display:flex; gap:8px; margin-top:10px; color:var(--muted); font-size:12px}
  .kbd{border:1px solid var(--outline); padding:2px 6px; border-radius:8px; background:#f8fafc}

  .footer{margin-top:16px; color:var(--muted); font-size:12px}
  .pill{display:inline-block; padding:3px 8px; border:1px solid var(--outline); border-radius:999px; margin-right:6px; background:#fafafa}

  /* Test output styles */
  #tests{margin-top:16px; font-size:13px; color:#111827}
  #tests .ok{color:#065f46;}
  #tests .fail{color:#b91c1c;}
  #tests code{background:#f3f4f6; padding:2px 6px; border-radius:6px}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">üóÇÔ∏è Outline Checklist (paste or import .txt with indentation)</div>
      <div class="controls">
        <label class="file" for="file">Import .txt</label>
        <input id="file" type="file" accept=".txt,text/plain" />
        <button class="btn" id="loadFromText">Load From Text</button>
        <button class="btn" id="expandAll">Expand All</button>
        <button class="btn" id="collapseAll">Collapse All</button>
        <button class="btn secondary" id="save">Save</button>
        <button class="btn secondary" id="load">Load</button>
        <button class="btn good" id="export">Export .json</button>
      </div>
    </header>

    <div class="grid">
      <section class="card">
        <h3>Paste outline (tabs or 2‚Äì4 spaces per level) ‚Üí then ‚ÄúLoad From Text‚Äù</h3>
        <div class="content">
          <textarea id="paste" placeholder="Example\nProject Alpha\n  Research\n    Read papers\n    Summarize findings\n  Build prototype\n    Backend\n      APIs\n    Frontend\n      UI draft\n  Launch prep\n    Checklist\n      Record trailer\n      Edit trailer\n      Upload assets\n"></textarea>
          <div class="badges">
            <div class="kbd">Supports tabs or spaces for nesting</div>
            <div class="kbd">Parents get tri‚Äëstate checkboxes</div>
            <div class="kbd">Save/Load uses localStorage</div>
          </div>
        </div>
      </section>

      <section class="card">
        <h3>Your checklist</h3>
        <div class="content">
          <ul id="tree" class="tree"></ul>
          <div class="footer">
            <span class="pill">Click ‚ñ∏ to expand</span>
            <span class="pill">Shift+Click ‚ñ∏ toggles all descendants</span>
            <span class="pill">Alt+Click checkbox checks whole subtree</span>
          </div>
          <div id="tests"></div>
        </div>
      </section>
    </div>
  </div>

  <script>
  // ---------- Data structures ----------
function makeNode(text){
  return { id: crypto.randomUUID(), text: text.trimEnd(), checked:false, expanded:true, attachments:[], children:[] };
}

// Parse indented text into a tree. Supports tabs or 2‚Äì8 leading spaces per level.
function parseOutline(input){
  // FIX: normalize line breaks (Windows, Unix, classic Mac) to "\n"
  const lines = input.replace(/\r?\n|\r/g, "\n").split("\n");
  const root = makeNode("__root__");
  const stack = [{level:-1, node:root}];

  for(let raw of lines){
    if(!raw.trim()) continue; // skip blank
    const {level, text: rawText} = measureIndent(raw);

    // Extract angle-bracket attachments and remove from task text
    const atts = Array.from(rawText.matchAll(/<([^>]*)>/g)).map(m=>m[1].trim()).filter(Boolean);
    const cleaned = rawText.replace(/<[^>]*>/g, '').trimEnd();

    // If line only contained attachments, skip creating a task node
    if(!cleaned.trim()){
      continue;
    }

    const node = makeNode(cleaned);
    node.attachments = atts;

    // find parent for this level
    while(stack.length && stack[stack.length-1].level >= level){ stack.pop(); }
    stack[stack.length-1].node.children.push(node);
    stack.push({level, node});
  }
  return root.children;
}

function measureIndent(line){
  // Count leading tabs or spaces. Tabs = 1 level; spaces: every 2+ spaces -> 1 level (round down by 2)
  let i=0, tabs=0, spaces=0;
  while(i < line.length){
    const ch = line[i];
    if(ch==='\t'){ tabs++; i++; }
    else if(ch===' '){ spaces++; i++; }
    else break;
    }
  const level = tabs + Math.floor(spaces/2);
  const text = line.slice(i);
  return {level, text};
}

// ---------- Rendering ----------
  const treeEl = document.getElementById('tree');

  function renderTree(nodes, container){
    container.innerHTML = '';
    for(const n of nodes){
      container.appendChild(renderNode(n));
    }
  }

  function renderNode(node){
  const li = document.createElement('li');
  li.className = 'node';
  if(node.checked) li.classList.add('done');

  const toggle = document.createElement('div');
  toggle.className = 'toggle';
  toggle.textContent = node.children.length && node.expanded ? '‚ñº' : '‚ñ∂';
  if(!node.children.length) toggle.classList.add('leaf');

  const row = document.createElement('div');
  row.className = 'label-row';

  const cb = document.createElement('input');
  cb.type = 'checkbox';
  cb.checked = !!node.checked;
  const label = document.createElement('div');
  label.className = 'text';
  label.textContent = node.text || '(untitled)';

  row.appendChild(cb); row.appendChild(label);

  const kids = document.createElement('ul');
  kids.className = 'children';
  if(!node.expanded) kids.style.display = 'none';
  for(const c of node.children){ kids.appendChild(renderNode(c)); }

  li.appendChild(toggle);
  li.appendChild(row);
  if(node.children.length) li.appendChild(kids);

  // Render attachments (not tasks) as chips
  if(node.attachments && node.attachments.length){
    const at = document.createElement('div');
    at.className = 'attachments';
    for(const a of node.attachments){
      const chip = document.createElement('span');
      chip.className = 'chip';
      chip.textContent = a;
      at.appendChild(chip);
    }
    li.appendChild(at);
  }

  // --- interactions ---
  toggle.addEventListener('click', (e)=>{
    if(e.shiftKey){ // toggle all descendants recursively
      const targetState = !node.expanded;
      toggleSubtreeExpansion(node, targetState);
      render();
      return;
    }
    node.expanded = !node.expanded;
    render();
  });

  cb.addEventListener('change', (e)=>{
    if(e.altKey){ // alt-click checks entire subtree
      setCheckedDeep(node, cb.checked);
    }else{
      node.checked = cb.checked;
      // if leaf, just bubble up; if parent, apply to children too
      if(node.children.length) setCheckedDeep(node, cb.checked);
    }
    bubbleTriState();
    render();
  });

  // Set tri-state appearance during render
  setCheckboxTriState(cb, node);

  return li;
}

  function setCheckedDeep(node, val){
    node.checked = val;
    for(const c of node.children){ setCheckedDeep(c, val); }
  }

  function getChildrenCheckStats(node){
    if(!node.children.length) return {all: node.checked, any: node.checked};
    let all=true, any=false;
    for(const c of node.children){
      const s = getChildrenCheckStats(c);
      all = all && s.all;
      any = any || s.any;
    }
    return {all, any};
  }

  function setCheckboxTriState(cb, node){
    if(!node.children.length){ cb.indeterminate = false; return; }
    const stats = getChildrenCheckStats(node);
    if(stats.all){ cb.checked = true; cb.indeterminate = false; }
    else if(stats.any){ cb.checked = false; cb.indeterminate = true; }
    else { cb.checked = false; cb.indeterminate = false; }
  }

  function bubbleTriState(){
    // Nothing to compute here directly; we re-render and recompute via getChildrenCheckStats
  }

  function toggleSubtreeExpansion(node, state){
    node.expanded = state;
    for(const c of node.children){ toggleSubtreeExpansion(c, state); }
  }

  // ---------- Controls ----------
  const fileEl = document.getElementById('file');
  const pasteEl = document.getElementById('paste');
  document.getElementById('loadFromText').addEventListener('click', ()=>{
    const text = pasteEl.value.trim();
    if(!text){ alert('Paste an indented outline first.'); return; }
    state.nodes = parseOutline(text);
    render();
  });

  fileEl.addEventListener('change', async (e)=>{
    const f = e.target.files?.[0];
    if(!f) return;
    const text = await f.text();
    state.nodes = parseOutline(text);
    render();
    e.target.value = '';
  });

  document.getElementById('expandAll').addEventListener('click', ()=>{ for(const n of state.nodes) toggleSubtreeExpansion(n, true); render(); });
  document.getElementById('collapseAll').addEventListener('click', ()=>{ for(const n of state.nodes) toggleSubtreeExpansion(n, false); render(); });

  document.getElementById('save').addEventListener('click', ()=>{
    localStorage.setItem('outline-checklist-v1', JSON.stringify(state.nodes));
    flash('Saved to your browser');
  });
  document.getElementById('load').addEventListener('click', ()=>{
    const raw = localStorage.getItem('outline-checklist-v1');
    if(!raw){ alert('No saved outline found in this browser.'); return; }
    try{ state.nodes = JSON.parse(raw); render(); }
    catch{ alert('Saved data was corrupted.'); }
  });

  document.getElementById('export').addEventListener('click', ()=>{
    const blob = new Blob([JSON.stringify(state.nodes, null, 2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'outline-checklist.json';
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
  });

  function flash(msg){
    const n = document.createElement('div');
    n.textContent = msg;
    n.style.position='fixed'; n.style.right='20px'; n.style.bottom='20px';
    n.style.padding='10px 14px'; n.style.background='#0f2c25'; n.style.border='1px solid #2a5'; n.style.borderRadius='12px';
    n.style.color='#ccffe8'; n.style.boxShadow='0 12px 30px #00000055'; n.style.zIndex='9999';
    document.body.appendChild(n);
    setTimeout(()=>n.remove(), 1400);
  }

  // ---------- State & initial render ----------
  const state = { nodes: [] };

  function render(){ renderTree(state.nodes, treeEl); }

  // Seed with a small demo so it looks nice on first load
  pasteEl.value = `Weekly Admin\n  Gather Paper/Receipts\n  File Into Binder/Folder\n  Label And Store\n  Record Receipts Digitally\n  Organize By Category/Date\n  Income\n    SSI Spending Records\n    Earned Income Receipts`;

  state.nodes = parseOutline(pasteEl.value);
  render();

  // ---------- Test harness ----------
  (function runTests(){
    const T = [];
    function eq(name, a, b){
      const pass = JSON.stringify(a) === JSON.stringify(b);
      T.push({name, pass, expect:b, got:a});
    }

    // 1) Line ending normalization (\r\n, \n, \r)
    const mixed = 'A\r\n  B\n    C\rD';
    const out1 = parseOutline(mixed);
    eq('line-endings: root child count', out1.length, 2);
    eq('line-endings: first item text', out1[0].text, 'A');

    // 2) Spaces vs Tabs indentation
    const spacesTabs = 'Root\n  S1\n\tT1';
    const out2 = parseOutline(spacesTabs);
    eq('indent: 2-space child', out2[0].children[0].text, 'S1');
    eq('indent: tab sibling at level 1', out2[0].children[1].text, 'T1');

    // 3) Attachments are chips, not task text
    const attach = 'Task One <file.pdf> <https://example.com>\n  Child';
    const out3 = parseOutline(attach);
    eq('attachments: kept as chips length', out3[0].attachments.length, 2);
    eq('attachments: text without brackets', out3[0].text, 'Task One');

    // 4) Standalone attachment-only line should be ignored
    const attachOnly = 'Parent\n  <ignored.pdf>\n  Child';
    const out4 = parseOutline(attachOnly);
    eq('attachment-only line ignored', out4[0].children.length, 1);

    // 5) Empty/blank lines ignored
    const blanks = 'Top\n\n  Kid\n\n';
    const out5 = parseOutline(blanks);
    eq('blank lines ignored (child count)', out5[0].children.length, 1);

    // Render results
    const el = document.getElementById('tests');
    const ok = T.filter(t=>t.pass).length;
    const fail = T.length - ok;
    const rows = T.map(t=>`<div class="${t.pass?'ok':'fail'}">${t.pass?'‚úî':'‚úò'} ${t.name}${t.pass?'':` ‚Äî expected <code>${escapeHtml(JSON.stringify(t.expect))}</code> got <code>${escapeHtml(JSON.stringify(t.got))}</code>`}</div>`).join('');
    el.innerHTML = `<div><strong>Parser tests:</strong> ${ok}/${T.length} passed</div>` + rows;
  })();

  function escapeHtml(s){
    return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
  }
  </script>
</body>
</html>
